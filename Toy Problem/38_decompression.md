# 문제
한 변의 길이가 2의 제곱수인 정사각형의 흑백 이미지가 2차원 배열로 주어집니다. 각 좌표에는 0(백) 또는 1(흑)이 저장되어 있습니다. 이미지에 포함된 데이터가 모두 1이면 '1', 모두 0이면 '0' 한 글자로 압축할 수 있습니다. 그렇지 않은 경우, 이를 대문자 X로 표시하고 전체를 4등분하여 재귀적으로 압축합니다. 4등분한 영역의 순서는 좌측 상단, 우측 상단, 좌측 하단, 우측 하단입니다.

## 입력
### 인자 1 : image
* 배열을 요소로 갖는 배열
* image.length, image[i].length는 1,024 이하
* image[i]는 number 타입을 요소로 갖는 배열
* image[i][j]는 세로로 i, 가로로 j인 지점의 정보를 의미
* image[i][j]는 0 또는 1

## 출력
* string 타입을 리턴해야 합니다.

## 주의사항
* 두 배열의 길이의 합은 1,000,000 이하입니다.
* 어떤 배열 arr의 k번째 요소는 arr[k-1]을 의미합니다.

## 입출력 예시
```javascript
let image = [
  [1, 0, 1, 1],
  [0, 1, 1, 1],
  [0, 0, 1, 1],
  [0, 0, 0, 0],
];
let result = decompression(image);
console.log(result); // --> 'XX100110X1100​'

image = [
  [0, 0, 0, 0, 1, 1, 0, 0],
  [0, 0, 0, 0, 1, 1, 0, 0],
  [0, 0, 0, 0, 1, 1, 1, 0],
  [0, 0, 0, 0, 1, 1, 1, 0],
  [1, 1, 1, 1, 0, 0, 0, 0],
  [1, 1, 1, 1, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 0, 1, 1],
  [1, 1, 1, 1, 0, 1, 1, 1],
];
result = decompression(image);
console.log(result); // --> 'X0X101X10101X00X10011'
```

## Advanced
* decompression과 반대로 정사각형으로 표현된 데이터를 압축한 문자열을 입력받아 원래의 사각형을 리턴하는 함수 compression을 작성해 보세요. 레퍼런스 코드는 따로 제공하지 않습니다.

## 문제풀이
```javascript
/*
const image = [
  [1, 0, 1, 1],
  [0, 1, 1, 1],
  [0, 0, 1, 1],
  [0, 0, 0, 0],
];

1. 전체 사각형(길이 4)에 0과 1이 섞여 있으므로 X가 첫 압축 정보가 됩니다. 
2. 그 뒤에는 차례대로 좌측 상단, 우측 상단, 좌측 하단, 우측 하단의 사각형이 압축된 정보가 나와야 합니다.
    => X[좌상][우상][좌하][우하]
3. 좌측 상단 사각형(길이 2)은 0과 1이 섞여 있으므로 X가 첫 압축 정보가 됩니다. 
   그리고 나머지 좌상, 우상, 좌하, 우하 사각형은 최소단위 이므로 차례대로 1, 0, 0, 1 을 그대로 적습니다.
    => X1001
   좌측 상단 사각형의 정보를 반영하면 전체 데이터의 압축 정보는 아래와 같습니다.
    => XX1001[우상][좌하][우하]
4. 우측 상단 사각형(길이 2)은 전부 1이므로 1이 곧 압축 정보입니다. 
    => XX10011[좌하][우하]
5. 좌측 히단 사각형(길이 2)은 전부 0이므로 0이 곧 압축 정보입니다. 
    => XX100110[우하]
6. 우측 하단 사각형(길이 2)은 0과 1이 섞여 있으므로 X가 첫 압축 정보가 됩니다. 
   그리고 나머지 좌상, 우상, 좌하, 우하 사각형은 최소단위 이므로 차례대로 1, 1, 0, 0 을 그대로 적습니다.
    => XX100110X1100
*/
const decompression = function (image) {
  const recursive = (Ys, Xs, Ye, Xe) => {
    // 재귀 보조 함수, base case
    // 1x1크기의 정사각형이 될 때 시작지점과 끝지점이 같으므로,
    if (Ys === Ye) {
      return `${image[Ys][Xs]}`;
    } 
   
    //중간값을 구해서 쪼개짐 4분면 각각의 시작과 끝지점에사용한다.
    let Ym = parseInt((Ys+Ye)/2)
    let Xm = parseInt((Xs+Xe)/2)
    
    // 좌측 상단, 우측상단, 좌측하단, 우측하단으로 분리한다.
    let leftup = recursive(Ys, Xs, Ym, Xm)
    //시작지점의 x좌표(image[y][x])는 중간값에 1을 더해줘야한다.
    let rightup = recursive(Ys, Xm+1, Ym, Xe)
    //시작지점의 y좌표(image[y][x])는 중간값에 1을 더해줘야한다.
    let leftdown = recursive(Ym+1, Xs, Ye, Xm)
    //시작지점의 y, x좌표(image[y][x])는 중간값에 1을 더해줘야한다.
    let rightdown = recursive(Ym+1, Xm+1, Ye, Xe)
    
    
    let result = leftup + rightup + leftdown + rightdown

    // 결과값이 '0000' 이거나 '1111'이면 '0' 혹은 '1'을 반환한다.
    // 상위의 결과값도 같게되면 동일하게 '0' 혹은 '1'을 반환한다.
    if (result === '0000') {
      return '0'
    } else if (result === '1111') {
      return '1'
    } else {
      // 결과값이 위의 두 경우 이외일 경우 'x'에 결과값을 이어붙인다. ex)'x1001'
      return 'X'+ result
    }
  }
  return recursive(0, 0, image.length-1, image.length-1)
};

```
